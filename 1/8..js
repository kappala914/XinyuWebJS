/* 
  ++i 和 i++ 的区别？
  相同点：都是在自身基础上累加1；
  不同点：计算和累加的顺序
    ++i 自身先累加1，根据累加后的结果进行运算
    i++ 先根据原始的值进行运算，运算完成后再累加1

  
 */

/* 
  GC：浏览器的垃圾回收机制，【内存管理】
    谷歌 -> 查找引用
    浏览器的渲染引擎会在空闲的时候（定期一个时间），依次遍历所有的内存：栈/堆
    堆：当前堆内存如果被占用（指针关联地址），则不能释放，如果没有任何事物占用这个堆，则浏览器会自动把这个堆内存释放掉；
    栈：当前上下文中是否有内容（一般指堆内存）被上下文以外的事物所占用，如果被占用则无法释放（闭包），如果没有被占用则释放掉；
        EC(G)是在加载页面的时候创建，只有关闭页面的时候才会被释放
    IE -> 引用计数
    每一个内存中都有一个数字N，记录被占用的次数
    如果当前内存被占用一次，则内存中的N会累加一次，反之取消占用，N会累减；直到N为0，则被释放掉

    下面的方案经常导致内存泄漏 思考题：总结内存泄漏的出现情况【高程三最后章节】

    内存的手动释放：
     把占用的事物赋值为null（其它值也可以，但是null更好，因为null是不占空间的）
 */

/* 
  let i = 1;
  console.log(5 + i++); // 5+(i++) 也是一样的效果 -> 5+i=6 i++:i=2
  console.log(i);

  i = 1;
  console.log(5 + ++i); // -> ++i：i=2   5+i=7
  console.log(i);


  let i = '1';
  i++;
  console.log(i); // ->2 i++ 和 ++i 一定是数学运算 [+N也是把N变为数字类型的值]
  i = '1';
  i += 1; // i = i+1
  console.log(i); // -> '11'

  let i = 2;
  console.log(2 + (++i) - (i++) +3 - (i--) + (--i));
  console.log(i);
 */

let x = 5;
function fn(x) {
  return function (y) {
    console.log(y + ++x);
  };
}
let f = fn(6);
f(7); // 14
fn(8)(9); // 18
f(10); // 18
console.log(x); // 5

/* 
  先输出，再累加
*/
let a = 0,
  b = 0;
function A(a) {
  A = function (b) {
    alert(a + b++);
    // console.log(a + b++);
  };
  alert(a++);
  // console.log(a++);
}
A(1); // '1'
A(2); // '4'
